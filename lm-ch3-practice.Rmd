---
title: "회귀분석 3장 연습문제 2022년 교재"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


## 연습문제 

## 1번 (p. 114)
다음 자료는 토양으로부터 증발되는 수분의 양이 토양의 온도, 대기온도와 어떠한 관계가 있는지를 알아보고자 수집한 것이다. <br>
MAXST: 토양 내 최고온도     <br>
MINST: 토양 내 최저온도     <br>
AVST:  토양 내 평균온도     <br>
MAXAT: 최고기온             <br>
MINAT: 최저기온             <br>
AVAT:  평균기온             <br>
EVAP:  증발되는 수분의 양   <br>

1) 설명변수간의 표본상관계수를 구하라. 이 행렬에서 설명변수들의 다중공선성을 말할 수 있는가? 
=> 설명어려움
2) 분산팽창인VIF(lm(AVST~MAXAT+MINAT+AVAT+DAY+MAXST, data=dataF))
자를 계산하라
=> 6개의 VIF 중 가장큰 값이 5~10을 넘으므로 다중공선성 존재
```{r}
DAY = c(6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30)
MAXST = c(84,84,79,81,84,74,73,75,84,86,88,90,88,88,81,79,84,84,84,77,87,89,89,93,93)
MINST = c(65,65,66,67,68,66,66,67,68,72,73,74,72,72,69,68,69,70,70,67,67,69,72,72,74)
AVST  = c(147,149,142,147,167,131,131,134,161,169,178,187,171,171,154,149,160,160,168,147,166,171,180,186,188)
MAXAT = c(85,86,83,83,88,77,78,84,89,91,91,94,94,92,87,83,87,87,88,83,92,92,94,92,93)
MINAT = c(59,61,64,65,69,67,69,68,71,76,76,76,75,70,68,68,66,68,70,66,67,72,72,73,72)
AVAT  = c(151,159,152,158,180,147,159,159,195,206,208,211,211,201,167,162,173,177,169,170,196,199,204,201,206)
EVAP  = c(30,34,33,26,41,4,5,20,31,38,43,47,45,45,11,10,30,29,23,16,37,50,36,54,44)

dataF = data.frame(DAY, MAXST, AVST, MAXAT, MINAT, AVAT, EVAP)
str(DAY)
str(AVST)
str(dataF)
#install.packages("corrplot")
library(corrplot)
plot(dataF)
matrixVal = matrix(dataF)
str(matrixVal)
cor(dataF)          
corrplot(cor(dataF), method="number")
```

```{r}
head(dataF)
data.lm = lm(EVAP~DAY+MAXST+AVST+MAXAT+MINAT+AVAT, data=dataF)
summary(data.lm)
anova(data.lm)
#install.packages("fmsb")
library(fmsb)
VIF(lm(DAY~MAXST+AVST+MAXAT+MINAT+AVAT, data=dataF))
VIF(lm(MAXST~AVST+MAXAT+MINAT+AVAT+DAY, data=dataF))
VIF(lm(AVST~MAXAT+MINAT+AVAT+DAY+MAXST, data=dataF))
VIF(lm(MAXAT~MINAT+AVAT+DAY+MAXST+AVST, data=dataF))
VIF(lm(MINAT~AVAT+DAY+MAXST+AVST+MAXAT, data=dataF))
```

## 2번 (p. 115)
1) 설명변수 간의 표본상관행렬을 구하라. 이 행렬에서 설명변수들의 선형종속관계를 말할 수 있는가?
=>cor(dataF[,-7]) 값을 보면 각 설명변수간에 선형종속관계가 약함
2) 분산팽창인자를 이용하여 다중공선성의 존재를 파악하라
=>5개의 VIF 중 가장큰 값이 5~10을 넘으므로 다중공선성 존재
```{r}
Y = c(10.006, 9.737, 15.087, 8.422, 8.625, 16.289, 5.958, 9.313, 12.960, 5.541, 8.756, 10.937)
X1=c(8,8,8,0,0,0,2,2,2,0,0,0)
X2=c(1,1,1,0,0,0,7,7,7,0,0,0)
X3=c(1,1,1,9,9,9,0,0,0,0,0,0)
X4=c(1,0,0,1,1,1,1,1,1,10,10,10)
X5=c(0.541, 0.130, 2.116, -2.397, -0.046, 0.365, 1.996, 0.228, 1.380, -0.798, 0.257, 0.440)
X6=c(-0.099, 0.070, 0.115, 0.252, 0.017, 1.504, -0.865, -0.055, 0.502, -0.399, 0.101, 0.432)
dataF = data.frame(X1,X2,X3,X4,X5,X6,Y)
cor(dataF[,-7])
head(dataF)
data.lm = lm(Y~X1+X2+X3+X4+X5, data=dataF)
summary(data.lm)
anova(data.lm)
#install.packages("fmsb")
library(fmsb)
VIF(lm(X1~X2+X3+X4+X5, data=dataF))
VIF(lm(X2~X3+X4+X5+X1, data=dataF))
VIF(lm(X3~X4+X5+X1+X2, data=dataF))
VIF(lm(X4~X5+X1+X2+X3, data=dataF))
VIF(lm(X5~X1+X2+X3+X4, data=dataF))
```

## 3번(p. 115)
교통사고의 원인을 알아보기 위해서 1973년 미국 미네소타주의 도로 39개 구간에서 자동차 주행거리 100만 마일당 사고의 횟수를 반응변수로 하고, 사고의 원인이 될 수 있는 것으로 예상되는 13개의 설명변수를 얻은 자료이다 <br>
Y: 100만 마일의 자동차 주행거리당 사고의 횟수 <br>
X1: 구간의 길이(miles)
X2: 일 평균 통과 자동차수(천 대)
X3: 트럭의 비율
X4: 제한속도(mile/hour)
X5: 차선의 폭(feet)
X6: 갓길의 폭(feet)
X7: 1마일당 고속도로 진입로의 수
X8: 1마일당 신호등이 있는 교차로의 수
X9: 1마일당 진입로의 수
X10: 차선의 수
X11: 1: 연방고속도로, 0: 기타
X12: 1: principal arterial highway, 0: 기타
X13: 1: major arterial highway, 0: 기타

```{r}
Y = c(4.58,2.86,3.02,2.29,1.61,6.87,3.85,6.12,3.29,5.88,4.20,4.61,4.80,3.85,2.69,1.99,2.01,4.22,2.76,2.55,1.89,2.34,2.83,1.81,9.23,8.60,8.21,2.93,7.48,2.57,5.77,2.90,2.97,1.84,3.78,2.76,4.27,3.05,4.12)
X1 = c(4.99,16.11,9.75,10.65,20.01,5.97,8.57,5.24,15.79,8.26,7.03,13.28,5.40,2.96,11.75,8.86,9.78,5.49,8.63,20.31,40.09,11.81,11.39,22.00,3.58,3.23,7.73,14.41,11.54,11.10,22.09,9.39,19.49,21.01,27.16,14.03,20.63,20.06,12.91)
X2 = c(69,73,49,61,28,30,46,25,43,23,23,20,18,21,27,22,19,9,12,12,15,8,5,5,23,13,7,10,12,9,4,5,4,5,2,3,1,3,1)
X3 = c(8,8,10,13,12,6,8,9,12,7,6,9,14,8,7,9,9,11,8,7,13,8,9,15,6,6,8,10,7,8,8,10,13,12,10,8,11,11,10)
X4 = c(55,60,60,65,70,55,55,55,50,50,60,50,50,60,55,60,60,50,55,60,55,60,50,60,40,45,55,55,45,60,45,55,55,55,55,50,55,60,55)
X5 = c(12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,13,12,12,12,12,12,12,12,12,12,12,12,11,13,12,10,12,12,11,12,12)
X6 = c(10,10,10,10,10,10,8,10,4,5,10,2,8,10,10,10,10,6,6,10,8,10,8,7,2,2,8,6,3,7,3,1,4,8,3,4,4,8,3)
X7 = c(1.20,1.43,1.54,0.94,0.65,0.34,0.47,0.38,0.95,0.12,0.29,0.15,0,0.34,0.26,0.68,0.20,0.18,0.14,0.05,0.05,0,0,0,0.56,0.31,0.13,0,0.09,0,0,0,0,0,0.04,0.07,0,0,0)
X8 = c(0,0,0,0,0,1.84,0.70,0.38,1.39,1.21,1.85,1.21,0.56,0,0.60,0,0.10,0.18,0,0.99,0.12,0,0.09,0,2.51,0.93,0.52,0.07,0.09,0,0.14,0,0,0.10,0.04,0,0,0,0)
X9 = c(4.60,4.40,4.70,3.80,2.20,24.80,11.00,18.50,7.50,8.20,5.40,11.20,15.20,5.40,7.90,3.20,11.00,8.90,12.40,7.80,9.60,4.30,11.10,6.80,53.00,17.30,27.30,18.00,30.20,10.30,18.20,12.30,7.10,14.00,11.30,16.30,9.60,9.00,10.40)
X10 = c(8,4,4,6,4,4,4,4,4,4,4,4,2,4,4,4,4,2,2,4,4,2,2,2,4,2,2,2,2,2,2,2,2,2,2,2,2,2,2)
X11 = c(1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)
X12 = c(0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)
X13 = c(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0)
str(X7)
dataF = data.frame(Y,X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13)
```
1) 앞으로부터 선택법을 이용하여 모형을 선택하라   <br>
=> 반영변수에 영향을 줄 것으로 생각되는 k개의 설명변수들 중에서 가장 큰게 영향을 줄 것으로 판단되는 변수부터 하나씩 선택하여 더 이상 중요한 변수가 없다고 판단될 때 변수의 선택을 중단하는 방법
```{r}
start.lm = lm(Y~1, data=dataF)
full.lm = lm(Y~ . , data=dataF)
step(start.lm, scope=list(lower=start.lm, upper=full.lm), direction="forward")
```
2) 뒤로부터 제거법을 이용하여 모형을 선택하라   <br>
=> 반응변수에 영향을 주리라고 생각되는 k 개의 설명변수들 중에서 가장 작게 영향을 주리라고 여겨지는 변수부터 하나씩 제거해 나가면서 더 이상 제거할 변수가 없다고 판단될 때 변수의 제거를 중단하는 방법  <br>
```{r}
step(full.lm, data=dataF, direction="backward")
```

3) 단계별 회귀방법을 이용하여 모형을 선택하라   <br>
=> 새로운 설명변수가 추가될 때마다 중요성을 상실하여 제가할 필요가 있는지를 매 단계별로 검토하는 선택방법
```{r}
step(start.lm, scope=list(upper=full.lm), data=dataF, direction="both")
```
4) 모든 회귀방법을 이용하여 모형을 선택하라  <br>
=> 2^k - 1  회귀모형을 적합하므로 계산량이 많은 모형   <br>
```{r}
#install.packages("leaps")
library(leaps)
str(Y)
all.lm=regsubsets(Y~. , data=dataF)
(rs=summary(all.lm))
```